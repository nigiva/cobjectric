# Quick Start

Get up and running with Cobjectric in 5 minutes and start computing metrics on your data.

## Installation

```bash
pip install cobjectric
```

## Define Your Model

First, create a model by subclassing `BaseModel` with typed fields:

```python
from cobjectric import BaseModel

class Person(BaseModel):
    name: str
    age: int
    email: str
```

## Compute Fill Rate

**Fill Rate** measures how "complete" your data is by checking which fields are filled vs missing.

```python
person = Person.from_dict({
    "name": "John Doe",
    "age": 30,
    # email is missing
})

result = person.compute_fill_rate()
print(result.fields.name.value)   # 1.0 (present)
print(result.fields.age.value)    # 1.0 (present)
print(result.fields.email.value)  # 0.0 (missing)
print(result.mean())              # 0.667 (2 out of 3 fields)
```

## Compare Data Completeness with Fill Rate Accuracy

**Fill Rate Accuracy** compares two objects to check if their field states match (both filled or both missing). It's useful for validating data pipeline outputs.

```python
# Data generated by your pipeline
got = Person.from_dict({"name": "John", "age": 30})  # email missing

# Expected data
expected = Person.from_dict({
    "name": "Jane",  # Different value (doesn't matter!)
    "age": 25,       # Different value (doesn't matter!)
    "email": "jane@example.com"
})

accuracy = got.compute_fill_rate_accuracy(expected)
print(accuracy.fields.name.value)   # 1.0 (both filled)
print(accuracy.fields.age.value)    # 1.0 (both filled)
print(accuracy.fields.email.value)  # 0.0 (got missing, expected filled)
print(accuracy.mean())              # 0.667
```

**Key point**: Fill Rate Accuracy **only checks state** (filled/missing), not actual values. The fact that `name` and `age` have different values doesn't affect the result.

## Validate Data Values with Similarity

If you want to also validate **actual values**, use **Similarity**. This compares field values with support for fuzzy matching.

```python
got = Person.from_dict({
    "name": "john doe",
    "age": 30,
    "email": "john@example.com"
})

expected = Person.from_dict({
    "name": "john doe",
    "age": 30,
    "email": "john@example.com"
})

similarity = got.compute_similarity(expected)
print(similarity.fields.name.value)   # 1.0 (exact match)
print(similarity.fields.age.value)    # 1.0 (exact match)
print(similarity.fields.email.value)  # 1.0 (exact match)
print(similarity.mean())              # 1.0
```

## Optional Fields

You can define optional fields using `| None`:

```python
class Person(BaseModel):
    name: str
    email: str | None

person = Person(name="John", email=None)
print(person.fields.email.value)  # None
```

## Handle Missing Values

If a required field is not provided or has an invalid type, it will have `MissingValue`:

```python
from cobjectric import MissingValue

person = Person(name="Jane", age="invalid")  # age is not an int
print(person.fields.age.value is MissingValue)  # True
```

## Next Steps

- Learn more about [Similarity](similarity.md) for fuzzy matching and value comparison
- Explore [Field Specifications](field_specs.md) to customize metric functions
- Check out [Pre-defined Specs](specs.md) for optimized configurations
- See [Examples](examples.md) for real-world scenarios

## API Reference

See the [API Reference](reference.md) for complete documentation of all classes and functions.
